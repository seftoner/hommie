---
mode: agent
model: Claude Sonnet 4
tools: ['codebase', 'usages', 'vscodeAPI', 'testFailure', 'terminalSelection', 'terminalLastCommand', 'fetch', 'searchResults', 'runTests', 'runCommands', 'runTasks', 'editFiles', 'search']
---

You are a senior Flutter architect. Build a declarative linear flow builder on top of go_router + go_router_builder and Riverpod 3 (codegen Notifier).

Constraints
	•	Flutter 3.x, go_router + go_router_builder (typed routes via @TypedGoRoute).
	•	Riverpod v3 with @riverpod Notifiers (codegen).
	•	State: in-memory only.
	•	Linear flow (no branches).
	•	Back behavior:
	•	System/back button ⇒ previous step if exists.
	•	Back on the first step ⇒ exit flow (pop).
	•	Deep links: can start the flow at any declared step (via startAt or external intent).
	•	Errors on next() ⇒ show toast (DI) + stay on the current step.
	•	Provide unit tests for the runner (forward/back/guard/error/success).
	•	No global singletons; everything via providers.

Public API

```dart
// flow_definition.dart
typedef StepId = String;

class FlowContext {
  final Ref ref;
  final Map<String, Object?> data;
  FlowContext(this.ref, [Map<String, Object?>? initial]) : data = initial ?? {};
  T read<T>(ProviderListenable<T> p) => ref.read(p);
  void put(String key, Object? v) => data[key] = v;
  T? get<T>(String key) => data[key] as T?;
}

/// A typed step that knows how to build a GoRouteData (generated by go_router_builder).
class RouteStep<T extends GoRouteData> {
  final StepId id;
  /// Build the typed route for navigation. Use ctx.data to pass extras via params/query.
  final T Function(FlowContext ctx) toRoute;
  final FutureOr<bool> Function(FlowContext ctx)? canProceed;
  final Future<void> Function(FlowContext ctx)? onEnter;
  const RouteStep({
    required this.id,
    required this.toRoute,
    this.canProceed,
    this.onEnter,
  });
}

class FlowDefinition {
  final String name;
  final List<RouteStep> steps; // linear order
  final StepId? startAt; // optional deep-link start
  final Future<void> Function(FlowContext ctx)? onSuccess;
  const FlowDefinition({
    required this.name,
    required this.steps,
    this.startAt,
    this.onSuccess,
  });
}

sealed class FlowState {
  const FlowState();
}
class FlowIdle extends FlowState { const FlowIdle(); }
class FlowInStep extends FlowState { final StepId stepId; final int index; const FlowInStep(this.stepId, this.index); }
class FlowDone extends FlowState { const FlowDone(); }
class FlowError extends FlowState { final StepId stepId; final Object error; final StackTrace stackTrace; const FlowError(this.stepId, this.error, this.stackTrace); }
```

```dart
// flow_runner.dart
abstract interface class FlowRunner {
  Future<void> start(FlowDefinition def, {Object? initialInput, StepId? startAt});
  Future<void> next();
  Future<void> back(); // back from first step => exit (pop)
  FlowDefinition? get definition;
  int? get currentIndex;
  FlowState get state;
}

@riverpod
class FlowRunnerNotifier extends _$FlowRunnerNotifier implements FlowRunner {
  late final GoRouter _router;
  FlowDefinition? _def;
  int? _idx;
  late FlowContext _ctx;

  @override
  FlowState build(GoRouter router) {
    _router = router;
    return const FlowIdle();
  }

  @override
  FlowDefinition? get definition => _def;
  @override
  int? get currentIndex => _idx;

  @override
  Future<void> start(FlowDefinition def, {Object? initialInput, StepId? startAt}) async {
    _def = def;
    _ctx = FlowContext(ref);
    final steps = def.steps;
    _idx = _resolveStartIndex(steps, def.startAt ?? startAt);
    await _enterCurrentStep();
  }

  int _resolveStartIndex(List<RouteStep> steps, StepId? startAt) {
    if (startAt == null) return 0;
    final i = steps.indexWhere((s) => s.id == startAt);
    return i < 0 ? 0 : i;
    // Tip: if deep link opens a step externally, caller can pass startAt matching that step's id.
  }

  Future<void> _enterCurrentStep() async {
    final i = _idx!;
    final step = _def!.steps[i];
    state = FlowInStep(step.id, i);
    if (step.onEnter != null) await step.onEnter!(_ctx);

    // go_router_builder integration: navigate via typed route's `location`
    final data = step.toRoute(_ctx) as GoRouteData;
    _router.go(data.location);
  }

  @override
  Future<void> next() async {
    final i = _idx!;
    final step = _def!.steps[i];
    try {
      final ok = await (step.canProceed?.call(_ctx) ?? Future.value(true));
      if (!ok) return;
      if (i + 1 >= _def!.steps.length) {
        state = const FlowDone();
        await _def!.onSuccess?.call(_ctx);
        return; // caller decides what to do (e.g., pop)
      }
      _idx = i + 1;
      await _enterCurrentStep();
    } catch (e, st) {
      ref.read(toastProvider).show('Error: $e');
      state = FlowError(step.id, e, st);
      state = FlowInStep(step.id, i);
    }
  }

  @override
  Future<void> back() async {
    final i = _idx!;
    if (i == 0) {
      _def = null;
      _idx = null;
      state = const FlowIdle();
      _router.pop();
      return;
    }
    _idx = i - 1;
    await _enterCurrentStep();
  }
}
```

```dart
// flow_providers.dart
final toastProvider = Provider<ToastService>((ref) => DebugToast());

@riverpod
FlowRunner flowRunner(FlowRunnerRef ref, GoRouter router) =>
    ref.watch(flowRunnerNotifierProvider(router).notifier);

@riverpod
Stream<FlowState> flowStates(FlowStatesRef ref, GoRouter router) =>
    ref.watch(flowRunnerNotifierProvider(router).stream);

abstract class ToastService { void show(String message); }
class DebugToast implements ToastService { @override void show(String m) => debugPrint('[TOAST] $m'); }
```


Sample of integration with go_router_builder

Routings (typed):
```dart
// routes.dart
part 'routes.g.dart';

@TypedGoRoute<ChooseModeRoute>(path: '/choose')
class ChooseModeRoute extends GoRouteData {
  const ChooseModeRoute();
  @override
  Widget build(BuildContext context, GoRouterState state) => const ChooseModePage();
}

@TypedGoRoute<DiscoverRoute>(path: '/discover')
class DiscoverRoute extends GoRouteData {
  final String? seed; // приклад query/param, якщо треба
  const DiscoverRoute({this.seed});
  @override
  Widget build(BuildContext context, GoRouterState state) => const DiscoverPage();
}

@TypedGoRoute<EnterManualRoute>(path: '/manual')
class EnterManualRoute extends GoRouteData {
  const EnterManualRoute();
  @override
  Widget build(BuildContext context, GoRouterState state) => const EnterManualPage();
}

@TypedGoRoute<SummaryRoute>(path: '/summary')
class SummaryRoute extends GoRouteData {
  const SummaryRoute();
  @override
  Widget build(BuildContext context, GoRouterState state) => const SummaryPage();
}
```

GoRouter:
```dart
final router = GoRouter(
  routes: $appRoutes, // згенерований масив
  // (за бажанням) глобальні редіректи/гварди
);
```
Flow description:
```dart
final addServerFlow = FlowDefinition(
  name: 'onboarding_add_server',
  steps: [
    RouteStep<ChooseModeRoute>(
      id: 'choose_mode',
      toRoute: (ctx) => const ChooseModeRoute(),
    ),
    RouteStep<DiscoverRoute>(
      id: 'discover',
      toRoute: (ctx) => DiscoverRoute(seed: ctx.get<String>('seed')),
      canProceed: (ctx) => (ctx.get<List>('hosts')?.isNotEmpty ?? false),
    ),
    RouteStep<EnterManualRoute>(
      id: 'enter_manual',
      toRoute: (ctx) => const EnterManualRoute(),
    ),
    RouteStep<SummaryRoute>(
      id: 'summary',
      toRoute: (ctx) => const SummaryRoute(),
    ),
  ],
  onSuccess: (ctx) async {
    final server = ctx.get('server');
    await ctx.read(serverRepoProvider).save(server);
  },
);

// запуск з deep-link на конкретний крок:
await ref.read(flowRunnerProvider(router)).start(addServerFlow, startAt: 'enter_manual');
```

UI у кроці:
```dart
class SummaryPage extends ConsumerWidget {
  const SummaryPage({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final runner = ref.read(flowRunnerProvider(GoRouter.of(context)));
    return Scaffold(
      appBar: AppBar(
        leading: BackButton(onPressed: () => runner.back()),
        title: const Text('Summary'),
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () => runner.next(), // на останньому кроці => FlowDone
          child: const Text('Finish'),
        ),
      ),
    );
  }
}
```