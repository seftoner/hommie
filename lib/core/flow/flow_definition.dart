import 'dart:async';

import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:go_router/go_router.dart';

typedef StepId = String;

class FlowContext {
  final Ref ref;
  final Map<String, Object?> data;

  FlowContext(this.ref, [Map<String, Object?>? initial]) : data = initial ?? {};

  /// Read a provider value directly - matches the same API as Riverpod Ref
  T read<T>(dynamic provider) => ref.read(provider);
  void put(String key, Object? v) => data[key] = v;
  T? get<T>(String key) => data[key] as T?;
}

/// A typed step that knows how to build a GoRouteData (generated by go_router_builder).
class RouteStep<T extends GoRouteData> {
  final StepId id;

  /// Build the typed route for navigation. Use ctx.data to pass extras via params/query.
  final T Function(FlowContext ctx) toRoute;
  final FutureOr<bool> Function(FlowContext ctx)? canProceed;
  final Future<void> Function(FlowContext ctx)? onEnter;

  const RouteStep({
    required this.id,
    required this.toRoute,
    this.canProceed,
    this.onEnter,
  });
}

class FlowDefinition {
  final String name;
  final List<RouteStep> steps; // linear order
  final StepId? startAt; // optional deep-link start
  final Future<void> Function(FlowContext ctx)? onSuccess;

  const FlowDefinition({
    required this.name,
    required this.steps,
    this.startAt,
    this.onSuccess,
  });
}

sealed class FlowState {
  const FlowState();
}

class FlowIdle extends FlowState {
  const FlowIdle();
}

class FlowInStep extends FlowState {
  final StepId stepId;
  final int index;

  const FlowInStep(this.stepId, this.index);
}

class FlowDone extends FlowState {
  const FlowDone();
}

class FlowError extends FlowState {
  final StepId stepId;
  final Object error;
  final StackTrace stackTrace;

  const FlowError(this.stepId, this.error, this.stackTrace);
}
