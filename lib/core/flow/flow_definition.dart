import 'dart:async';

import 'package:go_router/go_router.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:riverpod/riverpod.dart';

part 'flow_definition.freezed.dart';

typedef StepId = String;

class FlowContext {
  final Ref ref;
  final Map<String, Object?> data;

  FlowContext(this.ref, [Map<String, Object?>? initial]) : data = initial ?? {};

  /// Read a provider value directly - matches the same API as Riverpod Ref
  T read<T>(dynamic provider) => ref.read(provider);
  void put(String key, Object? v) => data[key] = v;
  T? get<T>(String key) => data[key] as T?;
}

/// A typed step that knows how to build a GoRouteData (generated by go_router_builder).
abstract class FlowStep {
  StepId get id;
  Future<void> onEnter(FlowContext ctx) async {}
  FutureOr<bool> canProceed(FlowContext ctx) => true;
  bool get isRoute;
}

class RouteStep<T extends GoRouteData> implements FlowStep {
  @override
  final StepId id;
  final T Function(FlowContext ctx) toRoute;
  final FutureOr<bool> Function(FlowContext ctx)? _canProceed;
  final Future<void> Function(FlowContext ctx)? _onEnter;

  const RouteStep({
    required this.id,
    required this.toRoute,
    FutureOr<bool> Function(FlowContext ctx)? canProceed,
    Future<void> Function(FlowContext ctx)? onEnter,
  }) : _canProceed = canProceed,
       _onEnter = onEnter;

  @override
  Future<void> onEnter(FlowContext ctx) async {
    if (_onEnter != null) {
      await _onEnter(ctx);
    }
  }

  @override
  FutureOr<bool> canProceed(FlowContext ctx) => _canProceed?.call(ctx) ?? true;

  @override
  bool get isRoute => true;
}

/// A non-navigation step executing side-effects (e.g., authentication) without changing route.
class ActionStep implements FlowStep {
  @override
  final StepId id;
  final Future<void> Function(FlowContext ctx)? _onEnter;
  final FutureOr<bool> Function(FlowContext ctx)? _canProceed;

  const ActionStep({
    required this.id,
    Future<void> Function(FlowContext ctx)? onEnter,
    FutureOr<bool> Function(FlowContext ctx)? canProceed,
  }) : _onEnter = onEnter,
       _canProceed = canProceed;

  @override
  Future<void> onEnter(FlowContext ctx) async {
    if (_onEnter != null) {
      await _onEnter(ctx);
    }
  }

  @override
  FutureOr<bool> canProceed(FlowContext ctx) => _canProceed?.call(ctx) ?? true;

  @override
  bool get isRoute => false;
}

class FlowDefinition {
  final String name;
  final List<FlowStep> steps; // linear order
  final StepId? startAt; // optional deep-link start
  final Future<void> Function(FlowContext ctx)? onSuccess;

  const FlowDefinition({
    required this.name,
    required this.steps,
    this.startAt,
    this.onSuccess,
  });
}

/// Base class for all flow states, implemented as a Freezed union.
@freezed
sealed class FlowState with _$FlowState {
  /// No flow currently active.
  const factory FlowState.idle() = FlowIdle;

  /// Currently executing a step.
  const factory FlowState.inStep(StepId stepId, int index) = FlowInStep;

  /// Flow reached its natural successful end.
  const factory FlowState.done() = FlowDone;

  /// An error occurred in the current step lifecycle (onEnter / canProceed / next logic).
  const factory FlowState.error(
    StepId stepId,
    Object error,
    StackTrace stackTrace,
  ) = FlowError;
}
